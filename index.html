<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maps | BrickMMO</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        #sidebar {
            position: absolute;
            left: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background: #222;
            color: #fff;
            z-index: 100;
            box-shadow: 2px 0 8px rgba(0,0,0,0.2);
            padding: 20px;
            font-family: sans-serif;
            box-sizing: border-box;
        }
        #container {
            position: absolute;
            left: 300px;
            top: 0;
            width: calc(100vw - 300px);
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            perspective: 1200px;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(27, 20px);
            grid-template-rows: repeat(30, 20px);
            gap: 1px;
            position: absolute;
            left: 0;
            top: 0;
            transform-origin: center center;
            transition: box-shadow 0.2s;
        }
        .square {
            width: 20px;
            height: 20px;
            box-sizing: border-box;
        }
        .ground { background: #996633; }
        .road { background: #888; }
        .track { background: #777; }
        .water { background: #3498db; } /* Blue for water */

        a:link,
        a:active,
        a:visited,
        a:hover {
            color: #ff5b00 !important;
            text-decoration: none !important;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <form id="searchForm" autocomplete="off" style="margin-bottom:20px;">
            <label for="searchInput" style="display:block;margin-bottom:8px;">Search Buildings:</label>
            <input type="text" id="searchInput" style="width:100%;padding:8px; box-sizing: border-box;" placeholder="Type to search..." />
        </form>
        <div id="searchResults"></div>
        <div id="profileView" style="display:none;"></div>
    </div>
    <div id="container">
        <div id="grid"></div>
    </div>
    <script>

        const cityId = 1;
        const rebrickableCdn = 'https://cdn.rebrickable.com/media/sets/';

        /*
         *
         * Load the map data from a local JSON file or API endpoint
         * 
         */
        fetch('map.json')
        // fetch('https://api.brickmmo.com/map/grid/city_id/' + cityId)
            .then(response => {
                if (!response.ok) throw new Error('Network response was not ok');
                return response.json();
            })  
            .then(data => {
                const gridDiv = document.getElementById('grid');
                data.squares.forEach(square => {
                    const isTrack = square.tracks > 0;
                    const isRoad = square.roads > 0;

                    let typeClass = square.type;
                    if (isTrack) typeClass = 'track';
                    if (isRoad) typeClass = 'road';

                    const div = document.createElement('div');

                    if(square.building) {
                        div.style.backgroundColor = square.building.colour;
                        div.dataset.buildingId = square.building.id;
                    }

                    div.className = 'square ' + typeClass;
                    div.title = `(${square.x}, ${square.y}): ${typeClass}`;
                    gridDiv.appendChild(div);

                    // Add click event to log type if not dragging
                    div.addEventListener('click', function(e) {
                        if (!isDragging && !isRotating3D && square.building) {
                            clearBuildingHighlights();
                            // Highlight matching search result if visible
                            var items = document.querySelectorAll('#searchResults div[data-building-id]');
                            for (var i = 0; i < items.length; i++) {
                                if (items[i].getAttribute('data-building-id') === String(square.building.id)) {
                                    // Remove previous selection
                                    var prevSelected = document.querySelector('#searchResults div.selected-result');
                                    if (prevSelected) {
                                        prevSelected.classList.remove('selected-result');
                                        var prevId = prevSelected.getAttribute('data-building-id');
                                        var prevSquares = document.querySelectorAll('.square[data-building-id="' + prevId + '"]');
                                        for (var k = 0; k < prevSquares.length; k++) {
                                            prevSquares[k].style.border = '';
                                        }
                                    }
                                    items[i].classList.add('selected-result');
                                }
                            }
                            // Highlight all matching squares
                            var squares = document.querySelectorAll('.square[data-building-id="' + square.building.id + '"]');
                            for (var k = 0; k < squares.length; k++) {
                                squares[k].style.border = '3px solid yellow';
                            }
                            // Load building profile
                            showBuildingProfile(square.building.id);
                        }
                    });
                });

                /*
                // Center the grid in the container
                const container = document.getElementById('container');
                const grid = document.getElementById('grid');
                // Get container and grid sizes
                const containerRect = container.getBoundingClientRect();
                const gridWidth = 27 * 20 + 26 * 1; // squares + gaps
                const gridHeight = 30 * 20 + 29 * 1;
                // Set initial offset to center
                offsetX = (containerRect.width - gridWidth) / 2;
                offsetY = (containerRect.height - gridHeight) / 2;
                grid.style.left = offsetX + 'px';
                grid.style.top = offsetY + 'px';
                */
               centerGridInContainer();
            })
            .catch(error => {
                console.error('Error loading maps.json:', error);
            });

        // Drag and 3D rotate logic
        const grid = document.getElementById('grid');
        const container = document.getElementById('container');
        let isDragging = false;
        let isRotating3D = false;
        let lastX = 0, lastY = 0;
        let offsetX = 0, offsetY = 0;
        let rotateX = 0, rotateY = 0;
        let scale = 1;

        container.addEventListener('mousedown', (e) => {
            if (e.button === 0 && !e.ctrlKey) { // Left click: 3D rotate
                isRotating3D = true;
                lastX = e.clientX;
                lastY = e.clientY;
            } else if (e.button === 2 || e.ctrlKey) { // Right click or Ctrl+Click: drag
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX += e.clientX - lastX;
                offsetY += e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                grid.style.left = offsetX + 'px';
                grid.style.top = offsetY + 'px';
            } else if (isRotating3D) {
                rotateY += (e.clientX - lastX) * 0.5;
                rotateX -= (e.clientY - lastY) * 0.5;
                lastX = e.clientX;
                lastY = e.clientY;
                // Clamp rotation so the map can't be flipped past the back
                rotateX = Math.max(-75, Math.min(75, rotateX));
                rotateY = Math.max(-75, Math.min(75, rotateY));
                grid.style.transform = `scale(${scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            }
        });

        container.addEventListener('mouseup', () => {
            isDragging = false;
            isRotating3D = false;
        });

        container.addEventListener('mouseleave', () => {
            isDragging = false;
            isRotating3D = false;
        });

        // Prevent context menu on right click
        container.addEventListener('contextmenu', e => e.preventDefault());

        // Touch support for mobile (optional, only 2D drag here)
        let lastTouchDist = null;
        container.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                isDragging = false;
                pinchStartDist = getTouchDist(e);
                pinchStartScale = scale;
            }
        });
        container.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1) {
                offsetX += e.touches[0].clientX - lastX;
                offsetY += e.touches[0].clientY - lastY;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
                grid.style.left = offsetX + 'px';
                grid.style.top = offsetY + 'px';
            } else if (e.touches.length === 2 && pinchStartDist !== null) {
                const newDist = getTouchDist(e);
                let newScale = pinchStartScale * (newDist / pinchStartDist);
                scale = Math.max(0.2, Math.min(3, newScale));
                grid.style.transform = `scale(${scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            }
        });
        container.addEventListener('touchend', (e) => {
            isDragging = false;
            if (e.touches.length < 2) {
                pinchStartDist = null;
            }
        });

        // Use scroll (wheel) to zoom in and out
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const container = document.getElementById('container');
            const grid = document.getElementById('grid');
            const gridHeight = 30 * 20 + 29 * 1;
            const minScale = Math.max(0.5, container.clientHeight / (2 * gridHeight));
            const maxScale = Math.min(3, (container.clientHeight * 0.95) / gridHeight);

            if (e.deltaY < 0) {
                scale += zoomIntensity;
            } else {
                scale -= zoomIntensity;
            }
            scale = Math.max(minScale, Math.min(maxScale, scale));
            // Clamp rotation so the map can't be flipped past the back
            rotateX = Math.max(-89, Math.min(89, rotateX));
            rotateY = Math.max(-89, Math.min(89, rotateY));
            grid.style.transform = `scale(${scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            clampOffsets();
        }, { passive: false });

        // Search form logic
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const profileView = document.getElementById('profileView');
        let searchTimeout = null;

        function attachResultEvents() {
            var items = searchResults.querySelectorAll('div[data-building-id]');
            for (var j = 0; j < items.length; j++) {
                items[j].addEventListener('mouseenter', function() {
                    var id = this.getAttribute('data-building-id');
                    var squares = document.querySelectorAll('.square[data-building-id="' + id + '"]');
                    for (var k = 0; k < squares.length; k++) {
                        squares[k].style.border = '3px solid yellow';
                    }
                });
                items[j].addEventListener('mouseleave', function() {
                    // Only remove highlight if not selected
                    var id = this.getAttribute('data-building-id');
                    if (!this.classList.contains('selected-result')) {
                        var squares = document.querySelectorAll('.square[data-building-id="' + id + '"]');
                        for (var k = 0; k < squares.length; k++) {
                            squares[k].style.border = '';
                        }
                    }
                });
                items[j].addEventListener('click', function() {
                    // Remove previous selection
                    var prevSelected = searchResults.querySelector('div.selected-result');
                    if (prevSelected) {
                        var prevId = prevSelected.getAttribute('data-building-id');
                        prevSelected.classList.remove('selected-result');
                        var prevSquares = document.querySelectorAll('.square[data-building-id="' + prevId + '"]');
                        for (var k = 0; k < prevSquares.length; k++) {
                            prevSquares[k].style.border = '';
                        }
                    }
                    // Highlight current selection
                    this.classList.add('selected-result');
                    var id = this.getAttribute('data-building-id');
                    var squares = document.querySelectorAll('.square[data-building-id="' + id + '"]');
                    for (var k = 0; k < squares.length; k++) {
                        squares[k].style.border = '3px solid yellow';
                    }
                    // Load building profile
                    showBuildingProfile(id);
                });
            }
        }

        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            const query = searchInput.value.trim();
            if (query.length === 0) {
                searchResults.innerHTML = '';
                profileView.style.display = 'none';
                searchResults.style.display = 'block';
                return;
            }
            searchTimeout = setTimeout(() => {
                clearBuildingHighlights();
                fetch('https://api.brickmmo.com/map/building/search/city_id/' + cityId + '/q/' + encodeURIComponent(query))
                    .then(res => res.json())
                    .then(data => {
                        if (Array.isArray(data.buildings) && data.buildings.length > 0) {
                            var html = '';
                            for (var i = 0; i < data.buildings.length; i++) {
                                var building = data.buildings[i];
                                html += '<div data-building-id="' + 
                                    building.id + 
                                    '" style="margin-bottom:8px; padding: 8px 0 0 0; border-top: 3px solid ' + 
                                    building.colour + ';">' + 
                                    building.name + '</div>';
                            }
                            html += '';
                            searchResults.innerHTML = html;
                            searchResults.style.display = 'block';
                            profileView.style.display = 'none';
                            attachResultEvents();
                        } else {
                            searchResults.innerHTML = '<div>No results found.</div>';
                            searchResults.style.display = 'block';
                            profileView.style.display = 'none';
                        }
                    })
                    .catch(() => {
                        searchResults.innerHTML = '<div>Error loading results.</div>';
                        searchResults.style.display = 'block';
                        profileView.style.display = 'none';
                    });
            }, 400);
        });

        function centerGridInContainer() {
            const container = document.getElementById('container');
            const grid = document.getElementById('grid');
            const gridWidth = 27 * 20 + 26 * 1; // squares + gaps
            const gridHeight = 30 * 20 + 29 * 1;
            const containerRect = container.getBoundingClientRect();
            offsetX = (containerRect.width - gridWidth * scale) / 2;
            offsetY = (containerRect.height - gridHeight * scale) / 2;
            grid.style.left = offsetX + 'px';
            grid.style.top = offsetY + 'px';
        }
        // Call on initial load after grid is created
        centerGridInContainer();

        // Recenter grid when window is resized
        window.addEventListener('resize', centerGridInContainer);

        function showBuildingProfile(buildingId) {
            fetch('https://api.brickmmo.com/map/building/city_id/' + cityId + '/building_id/' + buildingId)
                .then(res => res.json())
                .then(profile => {
                    var html = '<div style="margin-bottom:10px;"><a href="javascript: return false;" id="backToResults" style="margin-bottom:10px;">&larr; Back to Results</a></div>';
                    if (profile.building.colour) html += '<div style="margin-bottom: 10px; background-color:' + profile.building.colour + '; height: 5px;"></div>';
                    if (profile.building.name) html += '<h2 style="margin-top:0;">' + profile.building.name + '</h2>';
                    if (profile.road.name) html += '<p>' + profile.building.number + ' ' + profile.road.name + '<br>' + profile.city.name + '</p>';
                    if (profile.building.set) html += '<p>Set: <a href="https://www.lego.com/en-ca/product/' + profile.building.set + '">#' + profile.building.set + '</a></p>';
                    if (profile.building.set) html += '<img style="background-color:#fff; width:100%;" src="' + rebrickableCdn + profile.building.set + '-1.jpg">';
                    if (profile.building.colour) html += '<div style="margin-top: 10px; background-color:' + profile.building.colour + '; height: 5px;"></div>';
                    profileView.innerHTML = html;
                    searchResults.style.display = 'none';
                    profileView.style.display = 'block';

                    var backBtn = document.getElementById('backToResults');
                    if (backBtn) {
                        backBtn.addEventListener('click', function() {
                            profileView.style.display = 'none';
                            searchResults.style.display = 'block';
                            clearBuildingHighlights();
                        });
                    }
                })
                .catch(() => {
                    profileView.innerHTML = '<div>Error loading building profile.</div>';
                    searchResults.style.display = 'none';
                    profileView.style.display = 'block';
                });
        }

        function clearBuildingHighlights() {
            // Remove highlight from all squares
            var squares = document.querySelectorAll('.square[data-building-id]');
            for (var i = 0; i < squares.length; i++) {
                squares[i].style.border = '';
            }
            // Remove highlight from all search results
            var results = document.querySelectorAll('#searchResults div.selected-result');
            for (var i = 0; i < results.length; i++) {
                results[i].classList.remove('selected-result');
            }
        }

    </script>
</body>
</html>
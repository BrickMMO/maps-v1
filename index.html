<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Maps | BrickMMO</title>

    <style>
        body {
            margin: 0;
            padding: 0;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #sidebar {
            position: absolute;
            left: 0;
            top: 0;
            width: 400px;
            height: 100vh;
            background: #222;
            color: #fff;
            z-index: 100;
            box-shadow: 2px 0 8px rgba(0,0,0,0.2);
            padding: 20px;
            font-family: sans-serif;
            box-sizing: border-box;
        }
        #main {
            position: absolute;
            left: 400px;
            width: calc(100vw - 400px);
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            perspective: 1200px;
        }
        #grid {
            display: grid;
            grid-template-columns: repeat(27, 20px);
            grid-template-rows: repeat(30, 20px);
            gap: 1px;
            position: absolute;
            left: 0;
            top: 0;
            transform-origin: center center;
            transition: box-shadow 0.2s;
        }
        .square {
            width: 20px;
            height: 20px;
            box-sizing: border-box;
        }
        
        .ground { background: #996633; }
        .road { background: #888; }
        .track { background: #777; }
        .water { background: #3498db; } /* Blue for water */

        a:link,
        a:active,
        a:visited,
        a:hover,
        a {
            color: #ff5b00 !important;
            text-decoration: none !important;
            cursor: pointer;
        }
    </style>

</head>
<body>

    <div id="container">

        <div id="sidebar">

            <div style="text-align: center; margin-bottom: 20px;;">
                <img src="https://cdn.brickmmo.com/images@1.0.0/brickmmo-logo-coloured-horizontal.png" style="width: 80%;">
            </div>
            <div id="stopResults"></div>

            <form id="searchForm" autocomplete="off" style="margin-bottom:20px;">
                <input type="text" id="searchInput" style="font-size: 120%; width:100%;padding:8px; box-sizing: border-box;" />
            </form>
            <!--<button id="centerMapBtn" style="width:100%;margin-bottom:20px;">Center Map</button>-->
            
            <div id="searchResults"></div>
            <div id="profileView" style="display:none;"></div>

        </div>

        <div id="main">
            <div id="grid"></div>
        </div>

    </div>

    <script>

        const cityId = 1;
        const rebrickableCdn = 'https://cdn.rebrickable.com/media/sets/';

        /*
         *
         * Load the map data from a local JSON file or API endpoint.
         * 
         */
        fetch('map.json')
        // fetch('https://api.brickmmo.com/map/grid/city_id/' + cityId)

            // Convert json response to a JavaScript object
            .then(response => {
                if (!response.ok) throw new Error('Network response was not ok');
                return response.json();
            })  

            // Process the data and create the grid
            .then(data => {

                const gridDiv = document.getElementById('grid');

                data.squares.forEach(square => {
                    const isTrack = square.tracks > 0;
                    const isRoad = square.roads > 0;

                    let typeClass = square.type;
                    if (isTrack) typeClass = 'track';
                    if (isRoad) typeClass = 'road';

                    const div = document.createElement('div');

                    if(square.building) {
                        div.style.backgroundColor = square.building.colour;
                        div.style.cursor = "pointer"
                        div.dataset.buildingId = square.building.id;
                    }

                    div.className = 'square ' + typeClass;
                    div.title = `(${square.x}, ${square.y}): ${typeClass}`;
                    gridDiv.appendChild(div);

                    // Add click event if not dragging
                    div.addEventListener('click', function(e) {

                        if (!isDragging && !isRotating3D && square.building) {

                            clearBuildingHighlights();

                            // Highlight matching search result if visible
                            /*
                            var items = document.querySelectorAll('#searchResults div[data-building-id]');

                            for (var i = 0; i < items.length; i++) {
                                
                                if (items[i].getAttribute('data-building-id') === String(square.building.id)) {
                                    
                                    var prevSelected = document.querySelector('#searchResults div.selected-result');
                                    if (prevSelected) {
                                        prevSelected.classList.remove('selected-result');
                                        var prevId = prevSelected.getAttribute('data-building-id');
                                        var prevSquares = document.querySelectorAll('.square[data-building-id="' + prevId + '"]');
                                        for (var k = 0; k < prevSquares.length; k++) {
                                            prevSquares[k].style.border = '';
                                        }
                                    }
                                    items[i].classList.add('selected-result');
                                }
                            }
                            */

                            // Highlight all matching squares
                            var squares = document.querySelectorAll('.square[data-building-id="' + square.building.id + '"]');
                            for (var k = 0; k < squares.length; k++) {
                                squares[k].style.border = '3px solid yellow';
                            }

                            // Load building profile
                            showBuildingProfile(square.building.id);
                        }
                    });
                });

                /*
                // Center the grid in the main
                const main = document.getElementById('main');
                const grid = document.getElementById('grid');
                // Get main and grid sizes
                const mainRect = main.getBoundingClientRect();
                const gridWidth = 27 * 20 + 26 * 1; // squares + gaps
                const gridHeight = 30 * 20 + 29 * 1;
                // Set initial offset to center
                offsetX = (mainRect.width - gridWidth) / 2;
                offsetY = (mainRect.height - gridHeight) / 2;
                grid.style.left = offsetX + 'px';
                grid.style.top = offsetY + 'px';
                */

               centerGridInMain();

            })
            .catch(error => {
                console.error('Error loading maps.json:', error);
            });

        /*
         *
         * Dragging and 3D rotation logic.
         * 
         */
        const grid = document.getElementById('grid');
        const main = document.getElementById('main');

        let isDragging = false;
        let isRotating3D = false;
        let lastX = 0, lastY = 0;
        let offsetX = 0, offsetY = 0;
        let rotateX = 0, rotateY = 0;
        let scale = 1;

        main.addEventListener('mousedown', (e) => {
            if (e.button === 0 && !e.ctrlKey) { // Left click: 3D rotate
                isRotating3D = true;
                lastX = e.clientX;
                lastY = e.clientY;
            } 
            /*
            else if (e.button === 2 || e.ctrlKey) { // Right click or Ctrl+Click: drag
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            }
            */
        });

        main.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX += e.clientX - lastX;
                offsetY += e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                grid.style.left = offsetX + 'px';
                grid.style.top = offsetY + 'px';
            } else if (isRotating3D) {
                rotateY += (e.clientX - lastX) * 0.5;
                rotateX -= (e.clientY - lastY) * 0.5;
                lastX = e.clientX;
                lastY = e.clientY;
                // Clamp rotation so the map can't be flipped past the back
                rotateX = Math.max(-75, Math.min(75, rotateX));
                rotateY = Math.max(-75, Math.min(75, rotateY));
                grid.style.transform = `scale(${scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            }
        });

        main.addEventListener('mouseup', () => {
            isDragging = false;
            isRotating3D = false;
        });

        main.addEventListener('mouseleave', () => {
            isDragging = false;
            isRotating3D = false;
        });

        // Prevent context menu on right click
        main.addEventListener('contextmenu', e => e.preventDefault());

        /*
         *
         * Touch support for mobile (optional, only 2D drag here).
         * 
         */
        let lastTouchDist = null;
        main.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                isDragging = false;
                pinchStartDist = getTouchDist(e);
                pinchStartScale = scale;
            }
        });

        main.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1) {
                offsetX += e.touches[0].clientX - lastX;
                offsetY += e.touches[0].clientY - lastY;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
                grid.style.left = offsetX + 'px';
                grid.style.top = offsetY + 'px';
            } else if (e.touches.length === 2 && pinchStartDist !== null) {
                const newDist = getTouchDist(e);
                let newScale = pinchStartScale * (newDist / pinchStartDist);
                scale = Math.max(0.2, Math.min(3, newScale));
                grid.style.transform = `scale(${scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            }
        });

        main.addEventListener('touchend', (e) => {
            isDragging = false;
            if (e.touches.length < 2) {
                pinchStartDist = null;
            }
        });

        /*
         *
         * Use scroll (wheel) to zoom in and out.
         * 
         */
        main.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const gridHeight = 30 * 20 + 29 * 1;
            const minScale = Math.max(0.5, main.clientHeight / (2 * gridHeight));
            const maxScale = Math.min(3, (main.clientHeight * 0.95) / gridHeight);

            if (e.deltaY < 0) {
                scale += zoomIntensity;
            } else {
                scale -= zoomIntensity;
            }
            scale = Math.max(minScale, Math.min(maxScale, scale));
            rotateX = Math.max(-89, Math.min(89, rotateX));
            rotateY = Math.max(-89, Math.min(89, rotateY));
            grid.style.transform = `scale(${scale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            // clampOffsets();
            // centerGridInMain();
        }, { passive: false });

        
        /*
         *
         * Recenter grid when window is resized.
         * 
         */ 
        window.addEventListener('resize', function() {
            centerGridInMain();
        });

        /*
         *
         * Buildings serch form and results.
         * 
         */ 
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const profileView = document.getElementById('profileView');
        const stopResults = document.getElementById('stopResults');

        let searchTimeout = null;

        function attachResultEvents() {
            var items = searchResults.querySelectorAll('div[data-building-id]');
            for (var j = 0; j < items.length; j++) {
                items[j].addEventListener('mouseenter', function() {
                    var id = this.getAttribute('data-building-id');
                    var squares = document.querySelectorAll('.square[data-building-id="' + id + '"]');
                    for (var k = 0; k < squares.length; k++) {
                        squares[k].style.border = '3px solid yellow';
                    }
                });
                items[j].addEventListener('mouseleave', function() {
                    // Only remove highlight if not selected
                    var id = this.getAttribute('data-building-id');
                    if (!this.classList.contains('selected-result')) {
                        var squares = document.querySelectorAll('.square[data-building-id="' + id + '"]');
                        for (var k = 0; k < squares.length; k++) {
                            squares[k].style.border = '';
                        }
                    }
                });
                items[j].addEventListener('click', function() {
                    // Remove previous selection
                    var prevSelected = searchResults.querySelector('div.selected-result');
                    if (prevSelected) {
                        var prevId = prevSelected.getAttribute('data-building-id');
                        prevSelected.classList.remove('selected-result');
                        var prevSquares = document.querySelectorAll('.square[data-building-id="' + prevId + '"]');
                        for (var k = 0; k < prevSquares.length; k++) {
                            prevSquares[k].style.border = '';
                        }
                    }
                    // Highlight current selection
                    this.classList.add('selected-result');
                    var id = this.getAttribute('data-building-id');
                    var squares = document.querySelectorAll('.square[data-building-id="' + id + '"]');
                    for (var k = 0; k < squares.length; k++) {
                        squares[k].style.border = '3px solid yellow';
                    }
                    // Load building profile
                    showBuildingProfile(id);
                });
            }
        }

        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            const query = searchInput.value.trim();
            if (query.length === 0) {
                searchResults.innerHTML = '';
                profileView.style.display = 'none';
                searchResults.style.display = 'block';
                return;
            }
            searchTimeout = setTimeout(() => {
                clearBuildingHighlights();
                fetch('https://api.brickmmo.com/map/building/search/city_id/' + cityId + '/q/' + encodeURIComponent(query))
                    .then(res => res.json())
                    .then(data => {
                        if (Array.isArray(data.buildings) && data.buildings.length > 0) {
                            var html = '';
                            for (var i = 0; i < data.buildings.length; i++) {
                                var building = data.buildings[i];
                                html += '<div data-building-id="' + 
                                    building.id + 
                                    '" style="margin-bottom:8px; padding: 8px 0 0 0; border-top: 3px solid ' + 
                                    building.colour + ';">' + 
                                    building.name + '</div>';
                            }
                            html += '';
                            searchResults.innerHTML = html;
                            searchResults.style.display = 'block';
                            profileView.style.display = 'none';
                            attachResultEvents();
                        } else {
                            searchResults.innerHTML = '<div>No results found.</div>';
                            searchResults.style.display = 'block';
                            profileView.style.display = 'none';
                        }
                    })
                    .catch(() => {
                        searchResults.innerHTML = '<div>Error loading results.</div>';
                        searchResults.style.display = 'block';
                        profileView.style.display = 'none';
                    });
            }, 400);
        });

        /*
         *
         * Functions.
         * 
         */ 
        function centerGridInMain() {

            const main = document.getElementById('main');
            const mainRect = main.getBoundingClientRect();
            const grid = document.getElementById('grid');
            const gridCheck = document.getElementById('grid-check');
            const gridRect = grid.getBoundingClientRect();

            const gridWidth = 27 * 20 + 26 * scale;
            const gridHeight = 30 * 20 + 29 * scale;

            offsetX = (mainRect.width - gridWidth) / 2;
            offsetY = (mainRect.height - gridHeight) / 2;
            
            grid.style.left = offsetX + 'px';
            grid.style.top = offsetY + 'px';

        }

        // Call on initial load after grid is created
        centerGridInMain();

        // Recenter grid when window is resized
        window.addEventListener('resize', function() {
            centerGridInMain();
        });

        /*
        document.getElementById('centerMapBtn').addEventListener('click', function() {
            centerGridInMain();
        });
        */

        function showBuildingProfile(buildingId, target) {

            if (!target) target = 'profile';

            fetch('https://api.brickmmo.com/map/building/city_id/' + cityId + '/building_id/' + buildingId)
                .then(res => res.json())
                .then(profile => {

                    var html = '<div data-building-id="' + buildingId + '" data-square-id="' + profile.building.square_id + '" style="position:relative;">';
                    
                    if (target == 'profile') {
                        html += '<a href="javascript: void(0);" id="backToResults" style="display:block; margin-bottom:10px;">&larr; Back to Results</a>';
                        html += '<a href="javascript: void(0);" data-building-id="' + buildingId + '" id="addToStops" style="display:block; margin-bottom:10px;">&plus; Add to Stops</a>';
                    }

                    if (profile.building.colour) html += '<div style="margin: 10px 0; background-color:' + profile.building.colour + '; height: 5px;"></div>';
                    if (profile.building.name) html += '<h2 style="margin-top:0;">' + profile.building.name + '</h2>';

                    if (target == 'profile') {

                        if (profile.road.name) html += '<p>' + profile.building.number + ' ' + profile.road.name + '<br>' + profile.city.name + '</p>';
                        if (profile.building.set) html += '<p>Set: <a href="https://www.lego.com/en-ca/product/' + profile.building.set + '">#' + profile.building.set + '</a></p>';
                        if (profile.building.set) html += '<img style="background-color:#fff; width:100%;" src="' + rebrickableCdn + profile.building.set + '-1.jpg">';
                        if (profile.building.colour) html += '<div style="margin: 10px 0; background-color:' + profile.building.colour + '; height: 5px;"></div>';

                    }
                    else
                    {

                        html += '<a class="removeStop" style="display: block; position: absolute; top: 20px; right: 0;">&#x2716;</a>';
                        html += '<a class="reorderStop" style="display: block; position: absolute; top: 18px; right: 15px;">&#x2630;</a>';

                    }

                    html += '</div>';

                    searchResults.style.display = 'none';

                    if (target == 'profile') {

                        profileView.innerHTML = html;
                        profileView.style.display = 'block';

                        var backBtn = document.getElementById('backToResults');
                        backBtn.addEventListener('click', function() {
                            profileView.style.display = 'none';
                            searchResults.style.display = 'block';
                            clearBuildingHighlights();
                        });

                        var addBtn = document.getElementById('addToStops');
                        addBtn.addEventListener('click', function(e) {
                            profileView.style.display = 'none';
                            searchResults.style.display = 'block';
                            showBuildingProfile(e.target.dataset.buildingId, 'stop');
                            clearBuildingHighlights();
                            updateRoute();
                        });

                    }
                    else if (target == 'stop') {

                        stopResults.innerHTML += html;
                        stopResults.style.display = 'block';

                        searchInput.value = '';

                        attachRemoveEvents();

                    }
                    
                })

                .catch(() => {
                    profileView.innerHTML = '<div>Error loading building profile.</div>';
                    searchResults.style.display = 'none';
                    profileView.style.display = 'block';
                });

        }

        function attachRemoveEvents() {

            var removeButtons = stopResults.querySelectorAll('.removeStop');
            for (var i = 0; i < removeButtons.length; i++) {

                removeButtons[i].addEventListener('click', function(e) {
                    console.log('REMOVCE');
                    e.preventDefault();
                    e.target.parentElement.remove();
                    updateRoute();
                });
                
            }

            // Drag and drop for reorder
            var stopDivs = stopResults.querySelectorAll('div[data-building-id]');
            stopDivs.forEach(function(stopDiv) {
                var reorderBtn = stopDiv.querySelector('.reorderStop');
                if (reorderBtn) {
                    stopDiv.draggable = true;

                    // stopDiv.removeEventListener('dragstart');
                    stopDiv.addEventListener('dragstart', function(e) {
                        stopDiv.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                    });

                    // stopDiv.removeEventListener('dragend');
                    stopDiv.addEventListener('dragend', function(e) {
                        stopDiv.classList.remove('dragging');
                    });
                }
            });

            // stopResults.removeEventListener('dragover');
            stopResults.addEventListener('dragover', function(e) {

                e.preventDefault();

                var dragging = stopResults.querySelector('.dragging');
                var stopDivs = Array.from(stopResults.querySelectorAll('div[data-building-id]:not(.dragging)'));
                var afterElement = null;

                for (var i = 0; i < stopDivs.length; i++) {
                    var rect = stopDivs[i].getBoundingClientRect();
                    if (e.clientY < rect.top + rect.height / 2) {
                        afterElement = stopDivs[i];
                        break;
                    }
                }
                if (dragging) {
                    if (afterElement) {
                        stopResults.insertBefore(dragging, afterElement);
                    } else {
                        stopResults.appendChild(dragging);
                    }
                }

            });

            stopResults.addEventListener('drop', onStopDrag);
        }

        function onStopDrag(e) {
            e.stopPropagation();
            updateRoute();
        }

        function clearBuildingHighlights() {

            // Remove highlight from all squares
            var squares = document.querySelectorAll('.square[data-building-id]');
            for (var i = 0; i < squares.length; i++) {
                squares[i].style.border = '';
            }

            // Remove highlight from all search results
            var results = document.querySelectorAll('#searchResults div.selected-result');
            for (var i = 0; i < results.length; i++) {
                results[i].classList.remove('selected-result');
            }

        }

        function updateRoute() {
            console.log("CHANGE");
        }

    </script>

    <script 
        src="https://cdn.brickmmo.com/bar@1.1.0/bar.js"
        data-console="false"
        data-menu="false"
        data-admin="false"
        data-local="false"
        data-https="true"
    ></script>


</body>
</html>
